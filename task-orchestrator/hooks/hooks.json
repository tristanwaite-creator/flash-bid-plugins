{
  "Stop": [
    {
      "matcher": "",
      "hooks": [
        {
          "type": "prompt",
          "prompt": "## Orchestrator Loop Continuation Check\n\nBefore exiting, check if you are running as an orchestrator worker:\n\n### Step 1: Identify Worker Context\nLook in the conversation for evidence of being an orchestrator worker:\n- A worker name was assigned (e.g., \"alpha\", \"beta\", \"worker-xxxx\")\n- You previously executed `/orchestrate run as [NAME]` or `/orchestrate run`\n- You have been claiming and executing subtasks\n\n**If NO worker context found**: You are not an orchestrator worker. Allow exit normally.\n\n### Step 2: Check Worker Status\nRead `project-tasks.json` and check:\n- `workers.[YOUR_NAME].status` - if not \"running\", allow exit\n- `orchestrator_state.pause_all_requested` - if true, allow exit\n- `workers.[YOUR_NAME].iteration` - if >= 100, allow exit (max iterations)\n\n### Step 3: Find Ready Subtasks\n\n**IMPORTANT**: Subtasks are NESTED inside tasks:\n```\ntasks[0].subtasks[0], tasks[0].subtasks[1], ...\ntasks[1].subtasks[0], tasks[1].subtasks[1], ...\n```\n\nIterate through ALL tasks and their subtasks. Count subtasks where:\n- `status == \"pending\"`\n- `claimed_by == null` OR `claimed_by` is missing\n- `claim_intent` is missing OR `claim_intent.worker == null` OR expired\n- All `dependencies` have `status == \"completed\"`\n\n### Step 4: Decision\n\n**IF ready subtasks exist (count > 0):**\n1. Output: `[WORKER_NAME] continuing - [N] ready subtasks`\n2. Update `workers.[YOUR_NAME].last_heartbeat` to current timestamp\n3. Increment `workers.[YOUR_NAME].iteration`\n4. CLAIM the subtask:\n   - Set `subtask.claimed_by = \"[NAME]\"`\n   - Set `subtask.claimed_at = \"[now]\"`\n   - Set `subtask.status = \"in_progress\"`\n   - Save project-tasks.json\n5. **Use Task tool** to execute:\n   ```\n   Task tool with:\n   - subagent_type: \"task-orchestrator:subtask-executor\"\n   - prompt: \"Execute subtask [ID] as worker [NAME]. [Full subtask JSON]\"\n   ```\n   NOTE: If verification is a string, executor will run it as single command.\n6. After execution, update subtask status and repeat this check\n\n**IF no ready subtasks AND other workers still running:**\n- Other workers may complete dependencies that unblock subtasks\n- Wait briefly, then re-check\n\n**IF no ready subtasks AND no other workers running AND all subtasks completed:**\n- Output: `<promise>ALL_TASKS_COMPLETE</promise>`\n- Set `workers.[YOUR_NAME].status = \"idle\"`\n- Allow exit\n\n**IF all remaining subtasks are blocked:**\n- Output: `All [N] remaining subtasks are blocked`\n- Set `workers.[YOUR_NAME].status = \"paused\"`\n- Allow exit\n\n### Important\n- The `<promise>ALL_TASKS_COMPLETE</promise>` tag signals true completion\n- Only output this when genuinely ALL subtasks across ALL tasks are complete\n- Never output it if there are pending, in_progress, or blocked subtasks remaining"
        }
      ]
    }
  ]
}
